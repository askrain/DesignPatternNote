外观模式：Facade，在开发过程中使用率分厂高，尤其是第三方sdk很大概率会使用外观模式
通过一个外观类使得整个系统的接口只有一个同一的高层接口，这样能后降低用户的使用成本，而且对用户屏蔽了很多的
使用细节，外观模式也是我们封装api的常用手段


定义：
要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行处理。外观模式提供一个高层次的接口，使得子系统
更容易使用

子系统：app
内部：sdk

使用场景：
1.为一个复杂的子系统提供一个简单接口
2.当需要构建一个层次结构的子系统时，使用facade模式定义子系统中每层的入口点

Facade  系统对外的统一接口
SystemA SystemB SystemC

就是通过一个统一的接口对外提供服务，使得外部程序只通过一个类就可以实现系统内部的多宗功能，而这些
实现同能的内部子系统之间可能也有交互，或者说完成一个功能需要几个子系统之间进行协作。通过外观模式屏蔽了
这些复杂的交互，降低了用户的使用成本

生活中任何一个类似中央调度的结构的组织都类似外观模式，比如手机有打电话和拍照的功能，手机提供了同一的功能
实现


Android中的实现：

Context意为上下文，也就是程序的运行环境。它封装了很多操作，如startActivity() sendBroadcast()
bindService(). Context对于开发者来讲是最重要的高层接口，它还是一个定义了很多接口的抽象类，这些接口的
功能并不是在Context及其子类中实现的，而是通过其他子系统来完成。如
startActivity() 真正实现则是通过ActivityManagerService
获取包信息则是通过PackageManagerService来完成

如上，Context只是做了个高层次的封装，它的真正实现实在ContextImpl类中，ContextImpl就是我们要分析的外观类

ContextImpl内部封装了许多不同子系统的操作，如activity的跳转，广播的发送，设置壁纸，启动服务等。这些
工作并不是在ContextImpl中实现的，而是转交给了具体的子系统。通过这个Context抽象类就可以达到用户对
Android系统的交互，屏蔽了具体的细节，降低了使用成本，保证了系统的易用性和稳定性

对于SDK和开源库来说，外观模式是使用率最高的模式。

Android资源的加载与匹配
动态加载框架


总结：
是一个高频率的设计模式，精髓就在封装二字

优点：
对客户程序隐藏实现细节，减少客户和子系统之间的耦合。增加了易用性
缺点：
外观类的接口膨胀，增加了用户的使用成本