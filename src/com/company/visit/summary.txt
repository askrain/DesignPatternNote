访问者模式：
是一种将数据操作和数据结构分离的设计模式，它是23中设计模式中最复杂的一个。但它的使用率并不高。
但但你需要使用访问者模式的时候，你会真正的需要它

基本想法是：软件系统中拥有一个由许多对象构成的、比较稳定的对象结构，这些对象的类都拥有一个accept
方法来接受访问者对象的访问。访问者是一个接口，拥有一个visit方法，这些方法对访问到的对象结构中不同类型
的元素做出不同的处理。在对象结构的一次访问过程中，遍历整个对象结构，对每一个元素都实施accept方法
在每一个元素的accept方法中，都会调用访问者的visit方法，从而使访问者得以处理对象结构的每一个元素
我们可以针对对象结构设计不同的访问者类来完成不同的操作，达到区别对待的效果


定义：
封装一些作用于某种数据结构中各个元素的操作，它可以在不改变这个数据结构的前提下定义作用于这些元素的新的
操作

使用场景：
1.对象结构比较稳定，但经常需要在此对象结构上定义新的操作
2.需要对一个对象结构中的对象进行很多不同的并且不相关的操作。而需要避免这些操作“污染”这些对象的类。也不希望
在增加新操作的时候修改这些类


模型：
Visitor 接口或者抽象类，定义了对每一个元素Element访问的行为，它的参数就是可以访问的元素。它的方法
个数理论上与元素个数是一样的。因此，访问者模式要求元素的类族要稳定

ConcreteVisitor 具体的访问者，它需要给出对每一类元素的具体行为

Element 元素接口或者抽象类，定义了一个接受访问的方法。其意义是每一个元素都可以被访问到

ElementA ElementB 具体的元素类，提供了接受访问方法的具体实现，这个具体实现，是通过访问者
提供的访问此元素类的方法

ObjectStructure  定义当中所提到的对象结构，对象结构是一个抽象表述，它内部管理了元素集合，并且
可以迭代这些元素访问者访问

例子解释：
在年终考核时，不同的领导对员工的评价标准不一样。把员工分为工程师和经理，评定人员分为CTO/CEO，
CTO关注工程师的代码量，经理的新产品数量。
CEO关注工程师的kpi和经理的kpi以及新产品的数量
以上满足了区别对待的业务需求

Android源码中的访问者模式：注解
注解按照处理时期分为两个类型：
1.编译器注解
2.运行时注解

运行时注解因为性能问题，被一些人诟病。编译器注解的核心原理依赖APT（Annotation Processing Tools）
有代表的编译期注解有：BUtterKnife Dagger Retrofit等开源库都基于APT

编译器注解的基本原理是：在某些代码元素上（类型、函数、字段等）添加注解，在编译时，编译器会检查
AbstractProcessor的子类，并且调用该类型的process函数，然后将添加了注解的所有元素都传递到process
函数中，使得开发人员可以在编译器进行相应的处理，如根据注解生成新的Java类。这也就是BUtterKnife的
基本原理

JDK5中提供了对APT工具对注解进行处理。它是一个命令行工具，与之配套的还有Mirror API，它描述的是程序在编译
期的静态结构。通过Mirror API可以获取到被注解的Java类型元素的信息，从而提供相应的处理逻辑，具体的
处理工作交给APT工具来完成。
编写注解处理器的核心是：
AnnotationProcessorFactory  为某些注解类型创建注解处理器的工厂
AnnotationProcessor  注解处理器

对于编译器来说，代码的元素结构基本是不变的，组成代码的基本元素有包、类、函数、字段、类型参数、变量
JDK中为这些元素定义了基类，它有不同的子类分别对应上面的代码的各种基本元素

Element接口提供accept方法，参数为访问者对象和传递的数据
对应的访问者接口中则定义了对不同的元素的visit方法

编译器将代码抽象为一个代码元素的树，然后在编译时对整棵树进行遍历，每一个元素都有一个accept方法接受访问者
的访问，每个访问者中都有对应的visit方法。这样就达到了差异处理的效果。同时将数据结构和数据操作分离
使得每一个类型都职责单一，易于升级维护

注解相关实例：https:github.com/bboyfeiyu/InjectDagger

优点：
各角色职责分离，符合单一职责原则
具有优秀的扩展性
灵活

缺点：
具体元素对访问者公布细节，违反迪米特原则
具体元素变更时导致修改成本大
违反依赖导致原则，没有依赖抽象，而是依赖了具体类