责任链模式：
Iterator Pattern
是行为型设计模式之一
“链”是将多个节点首位相连所构成的模型。比如生活中常见的锁链。对于链型结构，每一个节点都可以
被拆开再连接，所以链式结构具有很好的灵活性。
在编程领域，可以将每一个节点看成是一个对象，每一个对象有不同的处理逻辑。将一个请求从链式的
首端出发，沿着链的路径依次传递给每一个节点对象，直至有对象处理这个请求为止，这一模式成为责任链模式


定义：
使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系。将这些对象连成一条链
并沿着这条链传递该请求。直到有对象处理它为止

使用场景：
1.多个对象可以处理一个请求，但具体由哪一个对象处理则在运行时动态决定
2.在请求处理者不明确的情况下向多个对象中的一个提交一个请求
3.需要动态指定一组对象处理请求

模型对象：
1.Client
2.Handler 抽象处理者角色，生命一个处理请求的抽象方法，并在其中保持对下一个处理节点Handler的引用
3.ConcreteHandler 具体的处理者，对请求进行处理，如果不能处理则将请求转发给下一个节点的处理对象

大多数情况下，责任链中的请求和对应的处理规则是不尽相同的，这种情况下可以封装请求，同时对请求的处理规则
也进行封装作为一个对立的对象

报销的例子很符合应用场景
在实际的应用场景中，可以直接越过组长赵主管报账，这也是责任链的灵活之处 。请求的发起可以从责任链的任何一个节点
开始，同时也可以改变责任链内部的传递规则

对于处理者对象：
有两个行为：
1.处理请求
2.将请求转发给下一个处理者

不允许处理者 处理了请求还转发请求到下一级处理者

一个请求最终有两种处理结果：
1. 纯的责任链：被某个处理对象处理
2.不纯的责任链（常见）：所有对象均为对其进行处理

在安卓中的应用为事件分发处理，另一种用法就是利用责任链模式来优化Broadcast Receiver使之成为
一个全局的责任链处理者  abortBroadcast()  setResultExtras(b)  getResultExtras(true)获取上一个
receiver增加的消息

然后再manifest清单中注册广播接受者  注意 priority的设置 发送广播的时候 sendOrderedBroadcast(intent,null)