享元模式：
是对象池的一种实现，英文名为flyweight，代表轻量级的意思。享元模式用来尽可能的减少内存使用量，它适合用于
可能存在大量重复对象的场景。来缓存可共享对象，达到共享对象，避免重复创建的效果

享元对象中的部分对象是可以共享的，可以共享的状态成为内部状态，内部状态不随着环境的变化而变化，不可共享
的状态称之为外部状态，他们会随着环境的变化而变化。享元模式中会建立一个对象容器，在经典的享元模式 中
该容器为一个map。它的键是享元对象的内部状态，他的值就是享元对象本身。这样，客户端程序通过这个内部状态
从享元工厂中获取享元对象，如果有缓存，则使用缓存，没有缓存则创建一个享元对象放入缓存。

定义：
使用享元对象可以有效地支持大量细粒度的对象

使用场景：
1.系统中存在大量的相似对象
2.细粒度的对象都具备较接近的外部状态，而且内部状态与环境无关，也就是说对象没有特定身份
3.需要缓冲池的场景

JDK中的String也是类似消息池，一般定义的String是存在与常量池中的。
String的equals只是根据字符值来进行判断。两个==表示用来判断这两个对象是否相等，也就是两个对象指向的
内存地址

Android中的运用：
Message
UI不可以在不是它的创建线程中进行更新

Android应用是事件驱动的，每个事件都会转化为一个系统消息，即Message.消息中包含了事件相关的信息
和这个消息的处理人----handler。每一个进程中都有一个默认的消息队列，即MessageQueue,这个消息队列
维持了一个待处理的消息列表，有一个消息循环不断的从这个队列中取出消息，处理消息。这样就使得应用动态地运作
起来了。它的工作原理就像是工厂的生产线一样，待加工的产品就是Message,Looper就是发动机。传送带就是MessageQueue，工人们就是
处理事件的Handler。
因为Android是事件驱动的，所以会产生很多的Message，使用享元模式很好的解决了系统的性能问题。

Message消息池没有使用map这样的容易，而是使用了来链表，next指向的是下一个Message
在创建Message的时候并不会把Message对象放到池中，在回收（并不是指虚拟机的回收操作）的时候，该对象才会被
添加到对应的链表中
插入或者获取都是从链表的头部

每个Handler都会关联一个消息队列，消息队列被封装在Looper中，而每个Looper又是ThreadLocal的，也就是说每个线程只
会属于一个线程


Looper属于某个线程，消息队列存储在Looper中。因此，消息队列就通过Looper与特定的线程关联起来。而
Handler又与Looper相关联，因此最终，handler就和线程、线程中的消息队列关联起来了。因此就可以通过handler
发送和不处理这个线程上的事件

handler使用的常规步骤：
1.Looper.prepare()  没有这一步会报错
2.handler =new Handler()
3.Looper.loop(); 没有这一步发送过来的消息虽然添加到了消息队列，但是没有启动消息循环，就不会获取这个消息并且执行

Looper对象封装了消息队列，Looper对象被封装在ThreadLocal中，使得不同的线程之间Looper不能被共享


总结：
享元模式在优化的场景中及其重要。大大较少了程序创建的对象，降低了内存的占用，增强了程序的性能。同时增加了
程序的复杂性

优点：大大降低了内存中对象的数目